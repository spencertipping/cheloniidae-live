#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

meta::meta('bootstrap::initialization', <<'__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU');

__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU

meta::meta('datatypes::bootstrap', <<'__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM');
meta::define_form 'bootstrap', sub {};
__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM

meta::meta('datatypes::code', <<'__VqQsjlm+HucvTRVlIGc8oi++EzzNq+rwy5bhKzunE8A');
meta::define_form 'code', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "code::$name";
  *{$name} = sub {
    return edit("code::$name")     unless defined $_[0];
    return unlit("code::$name")    if $_[0] eq 'unlit';
    return retrieve("code::$name") if $_[0] eq 'cat';
  };
};
__VqQsjlm+HucvTRVlIGc8oi++EzzNq+rwy5bhKzunE8A

meta::meta('datatypes::data', <<'__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U');
meta::define_form 'data', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "data::$name";
  *{$name} = sub {
    associate("data::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    retrieve("data::$name");
  };
};
__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U

meta::meta('datatypes::function', <<'__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0');
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "function::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0

meta::meta('datatypes::internal_function', <<'__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong');
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong

meta::meta('datatypes::library', <<'__Uu9nRiHABRn+x19zBWmHpJF8gbfMA5v5MlpNoSE8MqE');
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  eval $value;
  $externalized_functions{$name} = "library::$name";
  *{$name} = sub {edit("library::$name")};
  warn $@ if $@;
};
__Uu9nRiHABRn+x19zBWmHpJF8gbfMA5v5MlpNoSE8MqE

meta::meta('datatypes::list-type', <<'__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w');
meta::define_form '_list_type', sub {
  my ($outer_name, $outer_value) = @_;
  $externalized_functions{$outer_name} = "_list_type::$outer_name";
  
  *{$outer_name} = sub {
    associate("${outer_value}::$_", '') for @_;
  };

  meta::define_form $outer_value, sub {
    my ($name, $value) = @_;
    $externalized_functions{$name} = "${outer_value}::$name";
    *{$name} = sub {
      my ($command, @xs) = @_;
      my $xs = join "\n", @xs;
      return grep length, split /\n/, retrieve("${outer_value}::$name")               if $command eq 'items';
      associate("${outer_value}::$name", retrieve("${outer_value}::$name") . "\n$xs") if $command eq 'add' || $command eq '<<';
      edit("${outer_value}::$name")                                                   if $command eq 'edit';
      return retrieve("${outer_value}::$name");
    };
  };
};
__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w

meta::meta('datatypes::note', <<'__TGOjJwmj+QJp1giUQqg2bEaQe8RvqnrFEqyZhIpSC34');
meta::define_form 'note', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "note::$name";
  *{$name} = sub {edit("note::$name")};
};
__TGOjJwmj+QJp1giUQqg2bEaQe8RvqnrFEqyZhIpSC34

meta::meta('datatypes::sh', <<'__+0AR2hHnh+UldymM4MpYnXCE52tHTO+7Lp7HXSsKyTM');
meta::define_form 'sh', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "sh::$name";
  *{$name} = sub {
    my ($name, @args) = @_;
    my $filename      = state_based_filename() . '.tmp';
    my $new_value     = $value;

    @args || push(@args, $name) && ($name = 'unlit');

    file::write($filename, &$name(@args));
    $new_value =~ s/__code__/$filename/go;
    my $output = system($new_value);
    unlink $filename;
    $output;
  };
};
__+0AR2hHnh+UldymM4MpYnXCE52tHTO+7Lp7HXSsKyTM

meta::meta('datatypes::vim-highlighter', <<'__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0');
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0

meta::meta('internal::runtime', <<'__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA');
meta::define_form 'internal', \&meta::meta::implementation;
__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA

meta::_list_type('list', <<'__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk');
list
__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk

meta::bootstrap('initialization', <<'__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc');
#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc

meta::bootstrap('pod', <<'__3uM+GRhsAnxE6BFehM2nkGju4J93JQjqONxKbpE0Cdg');

=head1 NAME

object - Stateful file-based object

=head1 SYNOPSYS

object [options] action [arguments...]

object shell

=head1 DESCRIPTION

Stateful objects preserve their state between executions by rewriting themselves. Each time the script exits it replaces its contents with its new state. Thus
state management, for user-writable scripts, is completely transparent.

An object rewrites itself only if its state has changed. This may seem like a dangerous operation, but some checks are put into place to ensure that it goes
smoothly. First, the object is initially written to a separate file. Next, that file is executed and asked to provide a hashsum of its contents. The original
object is rewritten only if that hashsum is correct. This ensures that the replacement object is functional and has the right data.

Currently the only known way to lose your data is to edit the serialization-related functions in such a way that they no longer function. However, this is not
something most people will normally do. In the future there may be a locking mechanism to prevent unintentional edits of these attributes.

=cut

__3uM+GRhsAnxE6BFehM2nkGju4J93JQjqONxKbpE0Cdg

meta::code('debug', <<'__bdXm9ZJ6/nkYjI7hreB08QKB9Sg3V47eZypNWrGTV7I');
A debugging configuration that annotates Cheloniidae live

d.tracer = console.log.bind (console);
var preprocess = d.debug.trace;

:: get lib
__bdXm9ZJ6/nkYjI7hreB08QKB9Sg3V47eZypNWrGTV7I

meta::code('divergence-debug-lib', <<'__mHeYnWK4xBvNt9HxWaf0vgJKkLpn8iShCfTaJXPA/7M');
Divergence debug module | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license

This debug module enables expression-level debugging and tracing for functions. It records history (controlled by history-recording commands) and lets you replay sequences of events or
systematically search through them. Note that this can be arbitrarily memory-intensive; recording every single expression that goes through a system is an expensive way to debug things. To
compensate, there are calls you can make to start and stop tracing as your program is running. You can also set triggers depending on program values and use a sliding window.

The idea here is that a program evaluates expressions to achieve things. If we have a record of those evaluations, we can mostly reconstruct what the program was doing.

d.rebase (function () {
  var t = d.debug = _ >$> d.debug.init (this, arguments), global = this, syn = x >$> new d.rebase.syntax(null, x),
    set = xs >$> xs * '$0.maps_to(true)'.fn() / d.init, qw = s >$> s.split(/\s+/), qs = set.compose(qw);

  d.functions ({traced: function (options) {var f = this.fn(), options = options || {}, tracer = options.tracer || d.trace, name = options.name || 'anonymous', count = 0;
                                            return d.init (function () {var c = ++count;
                                                                        tracer ('#{name} (#{c}) called on #{this} with [#{Array.prototype.slice.call (arguments).join (", ")}]');
                                                                        try       {var result = f.apply (this, arguments); tracer ('#{name} (#{c}) returned #{result}'); return result}
                                                                        catch (e) {tracer ('#{name} (#{c}) threw #{e}'); throw e}},
                                                           {original: f})}});

  d.init (t, {ring_buffer: '@size = $0, @elements = $1 || [], @position = -1'.fn().ctor ({'<<': '@elements[@position = @position + 1 % @size] = $0, $_'.fn(),
                                                                                    'to_array': '@elements.slice(@position + 1).concat (@elements.slice(0, @position + 1))'.fn()}),
                 reserved:  qs('break continue default'),   first_only: qs('.'),
                     stop:  qs('++ -- u++ u-- new'),       second_only: qs('function catch = : += -= *= /= %= ^= |= &= <<= >>= >>>= in'),
                     skip:  qs('{ ( [ , ; ?: case var if while for do switch return throw delete export import try catch finally void with else'),
        protected_resolve:  qs('[! .'),

                    event: '@node = $0, @value = $1, @time = new Date()'.ctor ({toString: _ >$> '(#{this.node}) = (#{this.value}) at #{this.time.getTime()}'}),

                    trace: f >$> (new t.watcher() |$> (w >$> (w.use_tracing(), w.annotate (f)))),

                  watcher: '@name = d.gensym("hook"), @events = new $0.ring_buffer($1 && $1.log_size || 10000), @predicate = $1 && $1.predicate || (0).fn()'.fn(t).ctor ({
                                   use_logging: _ >$> (global[this.name] = this.hook_function (this.log.bind   (this))),
                                   use_tracing: p >$> (this.predicate = p || this.predicate, global[this.name] = this.hook_function (this.trace.bind (this))),
                            remove_global_hook: function () {delete global[this.name]; this.installed_hook = null; return this},

                                 hook_function: destination >$> ((index, value) >$> (destination (new t.event (this.trace_points[index], value)), value)).bind (this),

                                 annotate_tree: function (v) {global[this.name] || (this.installed_hook = this.use_logging());
                                                              var $_ = this,  trace_points = this.trace_points = this.trace_points || [],
                                                                             annotate_node = (s, v) >$> syn('(!') << $_.name << (syn('(') << (syn(',') << (trace_points.push(s) - 1) << v)),
                                                                         annotate_children =     v  >$> (v.xs ? (v.xs * annotate_tree).fold ((x, y) >$> x << y, syn(v.op)) : v),
                                                                             annotate_tree =     v  >$> (! v || t.reserved[v] ? v :
                                                                                                                 t.stop[v.op] ? annotate_node(v, v) :
                                                                                                                 t.skip[v.op] ? annotate_children(v) :
                                                                                                           t.first_only[v.op] ? syn(v.op) << annotate_tree(v.xs[0]) << v.xs[1] :
                                                                                                          t.second_only[v.op] ? syn(v.op) << v.xs[0] << annotate_tree(v.xs[1]) :
                                                                   v.op == '(!' && v.xs[0] && t.protected_resolve[v.xs[0].op] ? annotate_node (v,
                                                                                                                                  syn(v.op) << (syn(v.xs[0].op) << annotate_tree(v.xs[0].xs[0]) <<
                                                                                                                                                                   v.xs[0].xs[1]) <<
                                                                                                                                               annotate_tree (v.xs[1])) :
                                                                                                                       ! v.xs ? /^@?[A-Za-z_$][A-Za-z0-9_$]*$/.test(v) ? annotate_node(v, v) : v :
                                                                                                                                annotate_node (v, annotate_children (v)));
                                                              return annotate_tree (v)},

                                      annotate: f >$> d.rebase.deparse (this.annotate_local (f)),
                                annotate_local: f >$> this.annotate_tree (d.rebase.parse (f)).toString(),

                                         trace: e >$> (this.predicate(e) && d.trace(e)),
                                           log: e >$> (e ? this.events << e : this.events.to_array())})})}) ();

__mHeYnWK4xBvNt9HxWaf0vgJKkLpn8iShCfTaJXPA/7M

meta::code('divergence-lib', <<'__qKzrHnT3x3Es1rbotO3zXgu/BFGo4qmtRjXHqNxCJOA');
Divergence core library | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license

var d = (function () {
  var c = {}, d = function () {return d[d.default_action].apply (this, arguments)}, gensym_count = 0;
  d.init = function (o) {for (var i = 1, l = arguments.length, $_ = null; $_ = arguments[i], i < l; ++i) if ($_.call && $_.call.apply) $_.call (o);
                                                                                                         else                          for (var k in $_) $_.hasOwnProperty (k) && (o[k] = $_[k]); return o};
  d.init (d, {inline_macros:  [],            id: function    (x) {return x},
                functionals:  [],           arr: function    (o) {return Array.prototype.slice.call (o)},
      functional_extensions:  {},           map: function (o, f) {var x = {}; d.keys (o).each (function (k) {d.init (x, f (k, o[k]) || {})}); return x},
             default_action: 'init',       keys: function    (o) {var xs = []; for (var k in o) o.hasOwnProperty (k) && xs.push (k); return xs},
                                      functions: function     () {var as = d.arr (arguments); return d.functionals.each (function (p) {d.init.apply (this, [p].concat (as))}), d},
                                     functional: function     () {d.arr (arguments).each (function (f) {d.functionals.push (d.init (f, d.functional_extensions))}); return this},
                                         gensym: function    (s) {return 'gensym_' + (s || '') + (++gensym_count).toString(36)},
                                   macro_expand: function    (s) {return d.inline_macros.fold (function (s, m) {return m(s)}, s)},
                                          macro: function (r, f) {d.inline_macros.push (r.maps_to (f)); c = {}; return d},
                                          trace: function    (x) {d.tracer && d.tracer (d.arr (arguments).join (', ')); return x}});

  d (String.prototype, {maps_to: function (v) {var result = {}; result[this] = v; return result},
                         lookup: function  () {return '$0.split(".").fold("$0[$1]", $1)'.fn(this)},
                           fail: function  () {throw new Error (this.toString())},
                             fn: function  () {var s = this.toString(), f = c[s] || (c[s] = eval ('(function(){return ' + d.macro_expand(s) + '})')); return f.fn.apply (f, arguments)}});

  d (RegExp.prototype, {maps_to: function (f) {var s = this; return function (x) {return x.replace (s, f)}},
                          macro: function (f) {return d.macro (this, f)},
                             fn: function  () {var f = this.exec.bind (this); return f.fn.apply (f, arguments)}});

  d (Array.prototype, {flat_map: function (f) {var xs = [], f = f.fn(); this.each (function (x) {xs.push.apply (xs, f(x))}); return xs},
                        sort_by: function (f) {return this.sort ('$0($1) < $0($2)'.fn (f.fn()))},
                           each: function (f) {f = f.fn(); for (var i = 0, l = this.length; i < l; ++i) f (this[i]); return this},
                           grep: function (f) {var xs = [], f = f.fn(); for (var i = 0, l = this.length; i < l; ++i) f (this[i]) && xs.push (this[i]); return xs},
                           fold: function (f) {var f = f.fn(), xl = arguments.length, x = xl > 1 ? arguments[1] : this[0];
                                               for (var i = 2, l = xl + this.length; i < l; ++i) x = f (x, i < xl ? arguments[i] : this[i - xl]); return x},
                            map: function (f) {var xs = [], f = f.fn(); for (var i = 0, l = this.length; i < l; ++i) xs.push (f (this[i])); return xs},
                             fn: function  () {var xs = this, f = function () {return xs.map ('$1.fn().apply($_,$0)'.fn (arguments))}; return f.fn.apply (f, arguments)}});

  d (Function.prototype, {fn: function () {var f = this, xs = d.arr (arguments); return xs.length ? function () {return f.apply (this, xs.concat (d.arr (arguments)))} : f}});
  d  (Boolean.prototype, {fn: function () {return Number.prototype.fn.apply (1 - this.valueOf(), arguments)}});
  d   (Number.prototype, {fn: function () {var x = this, f = function () {return arguments[x]}; return f.fn.apply (f, arguments)}});

               /^\./ .macro ('(arguments[0] || this).');
                /@_/g.macro ('Array.prototype.slice.call(arguments)');
               /\$_/g.macro ('this');
           /\$(\d+)/g.macro ('"arguments[" + arguments[1] + "]"'.fn());
            /@(\w+)/g.macro ('"this." + $1'.fn());

  /\{\|([\w,\s]+)\|/g.macro ('"(function(" + $1 + "){return "'.fn()); /\|\}/g.macro ('})');
              /\{\</g.macro ('(function(){return ');                  /\>\}/g.macro ('})');

  (d.functionals = [Array, Number, Boolean, Function, String, RegExp].map ('.prototype')).push (d.functional_extensions);

  d.functions ({
      compose:  function (g) {var f = this.fn(); g = g.fn(); return function () {return f.apply (this, [g.apply (this, arguments)])}},
 flat_compose:  function (g) {var f = this.fn(); g = g.fn(); return function () {return f.apply (this,  g.apply (this, arguments) )}},
        curry:  function (n) {var f = this.fn(); return n > 1 ? function () {var as = d.arr(arguments); return function () {return f.curry (n - 1).apply (this, as.concat (d.arr (arguments)))}} : f},
        proxy:  function (g) {var f = this.fn(); return g ? function () {return f.apply.apply (f, g.fn().apply (this, arguments))} : function () {return f.apply (this, arguments)}},
         bind:  function (x) {var f = this.fn(); return d.init (function () {return f.apply (x, arguments)}, {binding: x, original: f})},
         type:  function  () {var f = function () {}, c = this.fn(); f = f.ctor.apply (f, arguments); return function () {return c.apply (new f(), arguments)}},
         ctor:  function  () {var g = function () {f.apply (this, arguments)}, f = g.original = this.fn(); d.init.apply (this, [g.prototype].concat (d.arr (arguments))); return g},
         tail: '[$_.fn(), arguments]'.fn(),
          cps:  function (c) {var cc = [this.fn(), [c = (c || d.id).fn().proxy()]]; while (cc[0] !== c) cc = cc[0].fn().apply (this, cc[1]); return c.apply (this, cc[1])}});

  return d}) ();

__qKzrHnT3x3Es1rbotO3zXgu/BFGo4qmtRjXHqNxCJOA

meta::code('divergence-rebase-lib', <<'__WaQoSM5hMIotoujTqinlSgnspTESmZqk1hQOaCrAYDQ');
Divergence Rebase module | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license

Rebase is a Divergence module that takes operator invocations inside functions and rewrites them to be method invocations. Naturally, new meaning can be associated with these constructs; this
is done by writing methods for them. For example, invocation of the '+' operator is translated into a call to the '+' method. Operator precedence is respected and follows the normal JavaScript
rules.

Certain constructs cannot be changed. These include assignment variants such as '+='; such variants are always expanded to their full forms (e.g. a += b becomes a = a + b, which becomes a =
a['+'](b)). Others include the behavior of 'new', dot-lookups, indexed lookups, function calls, and statement-mode constructs such as 'if', 'for', etc. You can write macros that transform
these things, but they will have strange limitations and might not behave as expected.

Since JavaScript is dynamically typed, it isn't possible to know in advance whether an operator overloading replacement will impact a primitive value. This is one reason for the limitations
described above. The other thing to realize is that those operators need to get replaced for standard things too -- so Number.prototype, String.prototype, and anything else that depends on
standard operators will have a bunch of replacement functions that delegate to those operators.

One more thing of importance. Some identifiers are treated specially and sandwiched between operators to form longer operators. They're defined in d.rebase.sandwiches. If an identifier appears
as a key there (e.g. 'foo'), then it will be sandwiched between binary operators, resulting in the translation of things like 'a + foo + b' as 'a['+foo+'](b)'. This means that you can't use
'foo' normally anymore, so use this feature carefully.

(function () {
  var set            = '.fold({< $0[$1] = true, $0 >}, {})'.fn(),            last = '$0[$0.length - 1]'.fn(),  qw = '.split(/\\s+/)'.fn(),
        r = d.rebase =   function  () {return r.init.apply (this, arguments)},  $ = null,
        s            =   function (x) {if (x === undefined || x === null) return ''; var s = x.toString(); return s.charAt(0) === '@' ? s.substring (1) : s};

  d.init (r, {precedence: {'function':1, '[!':1, '.':1, '(!':1, 'new':2, 'u++':3, 'u--':3, '++':3, '--':3, 'typeof':3, 'u~':3, 'u!':3, '!':3, '~':3, 'u+':3, 'u-':3, '*':4, '/':4, '%':4,
                           '+':5, '-':5, '<<':6, '>>':6, '>>>':6, '<':7, '>':7, '<=':7, '>=':7, 'instanceof':7, 'in':7, '==':8, '!=':8, '===':8, '!==':8, '&':9, '^':10, '|':11, '&&':12,
                           '||':13, '?':14, '=':15, '+=':15, '-=':15, '*=':15, '/=':15, '%=':15, '&=':15, '|=':15, '^=':15, '<<=':15, '>>=':15, '>>>=':15, 'case':16, ':':17, ',':18, 'var':19,
                           'if':19, 'while':19, 'for':19, 'do':19, 'switch':19, 'return':19, 'throw':19, 'delete':19, 'export':19, 'import':19, 'try':19, 'catch':19, 'finally':19, 'void':19,
                           'with':19, 'else':19, '?:':20, ';':21, '{':22, '(':22, '[':22},

                   unary: set(qw('u++ u-- ++ -- u+ u- u! u~ new typeof var case try finally throw return case else delete void import export ( [ { ?:')),
               syntactic: set(qw('case var if while for do switch return throw delete export import try catch finally void with else function new typeof in instanceof')),
               statement: set(qw('case var if while for do switch return throw delete export import try catch finally void with else')),
               connected: set(qw('else catch finally')),                                                                       digit: set('0123456789.'.split('')),
                   ident: set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_'.split ('')),                  punct: set('+-*/%&|^!~=<>?:;.,'.split ('')),
                   right: set(qw('= += -= *= /= %= &= ^= |= <<= >>= >>>= u~ u! new typeof u+ u- u++ u-- ++ --')),            openers: {'(':')', '[':']', '{':'}', '?':':'},
     implicit_assignment: set(qw('++ -- u++ u--')),                                                                       sandwiches: set(qw('$ $$ $$$ _ __ ___ _$ _$$ __$')),
                 literal: set(qw('= ++ -- u++ u-- (! [! . ?: , ? u! ( { [ === !== == != ; : && ||')),                   sandwich_ops: set(qw('+ - * / % ^ | & << >> >>> < >')),
           prefix_binary: set(qw('if function catch for switch with while')),                                                closers: {')':'(', ']':'[', '}':'{', ':':'?:'},
            translations: {'u+':'+', 'u-':'-', 'u~':'~', 'u!':'!', 'u--':'--', 'u++':'++'},                                 arity_of: '$0.unary[$1] ? 1 : $1 == "?" ? 3 : 2'.fn(r),
           lvalue_assign: set(qw('+= -= *= /= %= ^= |= &= <<= >>= >>>=')),                                            should_convert: '! ($0.literal[$1] || $0.syntactic[$1])'.fn(r),
               no_spaces: set(qw('.')),

                alias_in: '$0.init ($1, $0.map ($2, {|h, k, v| k.maps_to (h[v] || v.fn()) |}.fn($1)))'.fn(d),

                    init: '$0.deparse($0.transform($0.parse($1)))'.fn(r),
                   local: '$0.transform($0.parse($1)).toString()'.fn(r),

  Deparsing.
  This is certainly the easiest part. All we have to do is follow some straightforward rules about how operators and such get serialized. Luckily this is all encapsulated into the toString
  logic of the syntax tree.

                 deparse: 'eval($0.trace ? $0.trace ($1.toString()) : $1.toString())'.fn(r),

  Tree transformation.
  The goal here is to transform the tree in logical form before serializing it to a final function. The way I've chosen to go about this is to use a macro table and deep-map over the syntax
  tree. Each node gets inspected, and mapping functions can modify nodes by returning alternative values. To save space and time, I'm having macros replace structures halfway destructively
  rather than using a pure functional approach.

               translate: '$0.transform($0.parse($1)).toString()'.fn(r),
               transform: function (t) {if (t && t.op == '(!' && t.xs[0] == 'literal') return t.xs[1];
                                        var mapped = r.macros.fold ('$1($0) || $0', t);
                                        mapped && mapped.xs && (mapped.xs = mapped.xs.map ('$1 ? $0($1) : $1'.fn (r.transform)));
                                        return mapped},

  Lexing.
  The lexer is for the most part straightforward. The only tricky bit is regular expression parsing, which requires the lexer to contextualize operators and operands. I've implemented this
  logic with a expect_re flag that indicates whether the last token processed was an operator (if so, then we're expecting an operand and the next / delineates a regular expression).

  We mark the position before a token and then just increment the position. The token, then, can be retrieved by taking a substring from the mark to the position. This eliminates the need for
  intermediate concatenations. In a couple of cases I've gone ahead and done them anyway -- these are for operators, where we grab the longest contiguous substring that is defined. I'm not to
  worried about the O(n^2) complexity due to concatenation; they're bounded by four characters.

  Retrieving the Cartesian coordinates of the token is not difficult provided that we have a list of line lengths. We can then convert that list to a cumulative measure to enable binary
  searching. I realize this is more elaborate than necessary given that the lexer is streaming (and thus would never need to recover old line lengths), but having to keep track of each newline
  that occurs while reading the input is probably more expensive than the overhead incurred by O(log n) jumps every so often.

                   parse: function (s) {var mark = 0, s = s.toString(), i = 0, $_ = '', l = s.length, token = '', expect_re = true, escaped = false, t = new r.syntax(null, '('),
                                                      c = s.charAt.bind (s), openers = [],
                                             precedence = r.precedence, ident = r.ident, punct = r.punct, digit = r.digit,
                                            line_breaks = [0].concat (s.split('\n').map('.length')), lb = 1,
                                          located_token = function () {var jump = lb << 1, l = 0, r = new String (token);
                                                                       while (jump >>= 1) mark >= line_breaks[l + jump] && (l += jump);
                                                                       return r.line = l + 1, r.character = mark - line_breaks[l], r};
                          while ((lb <<= 1) < line_breaks.length);
                          for (var j = 0, lj = line_breaks.length, total = -1; j < lj; ++j) line_breaks[j] = total += line_breaks[j] + 1;

                          while ((mark = i) < l && ($_ = c(i))) {
          escaped = token = '';

               if                                (' \n\r\t'.indexOf ($_) > -1)                                                             {++i; continue}
          else if                               ('([{?:}])'.indexOf ($_) > -1)                                                              expect_re = '([{:?'.indexOf ($_) > -1, ++i;
          else if                 ($_ === '/' && c(i + 1) === '*' && (i += 2)) {while       (c(++i) !== '/' || c(i - 1) !== '*' || ! ++i);  continue}
          else if                             ($_ === '/' && c(i + 1) === '/') {while             (($_ = c(++i)) !== '\n' && $_ !== '\r');  continue}
          else if ($_ === '/' && expect_re && ! (expect_re = ! (token = '/'))) {while                  (($_ = c(++i)) !== '/' || escaped)   escaped = ! escaped && $_ === '\\';
                                                                                while                                     (ident[c(++i)]);}
          else if              ($_ === '"' && ! (expect_re = ! (token = '"')))  while         (($_ = c(++i)) !== '"' || escaped || ! ++i)   escaped = ! escaped && $_ === '\\';
          else if              ($_ === "'" && ! (expect_re = ! (token = "'")))  while         (($_ = c(++i)) !== "'" || escaped || ! ++i)   escaped = ! escaped && $_ === '\\';
          else if                    (expect_re && punct[$_] && (token = 'u'))  while        (punct[$_ = c(i)] && precedence[token + $_])   token += $_, ++i;
          else if                            (punct[$_] && (expect_re = true))  while        (punct[$_ = c(i)] && precedence[token + $_])   token += $_, ++i;
          else                                                                 {while (ident[$_ = c(++i)] || digit[c(mark)] && digit[$_]);  expect_re = precedence.hasOwnProperty (token = s.substring (mark, i))}

          expect_re && token.charAt(0) === 'u' || (token = s.substring (mark, i));
          token in {} && (token = '@' + token);

               if         (t.is_value() && '[('.indexOf (token) > -1)  openers.push (t = t.push_op (token + '!').graft (located_token()));
          else if (($_ = r.closers[token]) && last(openers).op == $_)  t = openers.pop().parent, token === '}' && t.is_value() && r.statement[t.op] && (t = t.push_op(';'));
          else if                                     (token === '?')  openers.push (t = t.push_op (located_token()).graft ('?:'));
          else if                                  (r.openers[token])  openers.push (t = t.graft (located_token()));
          else if                                 (precedence[token])  t = t.push_op (located_token());
          else                                                         t.push_value (located_token());
                          }
                          return t.top()},

  Incremental parsing.
  As tokens are read from the lexer they are written into a parse tree. Unlike a traditional grammar with productions, this parse tree works in terms of operators and values. Each element in
  the text is considered to have a certain precedence and to comprise part of an expression. This leads to a weird model and a much more general grammar than JavaScript's, but this is
  acceptable because we know that by the time we see the code it will be valid.

  The mechanics of this parser are fairly simple. We build a tree incrementally and include explicit nodes for parentheses (the role of these nodes will become apparent). Starting with the
  root node, which has no particular identity, we add expressions and operators to this tree. The rules for this are:

    | 1. When we add an expression to a tree, it is just added to the operand list. This will throw an error if there are too many operands.
    | 2. When we add an operator to a tree, we check the precedence. If the new operator binds first, then it is added as a child, given a value, and returned. Otherwise we add it to the
         parent.

                  syntax: '@parent = $0, @op = $1, @xs = $2 || [], $_'.ctor ({
                           is_value: '@xs.length >= $0.arity_of(@op)'.fn(r),
                                map: 'new $0.syntax(null, @op, @xs.map($1).map({|t, x| x.parent = t, x |}.fn($_)))'.fn(r),
                               find: '(@op == $0 || @xs.grep({|t, x| t == x |}.fn($0)).length ? [$_] : []).concat (@xs.flat_map({|t, v| v && v.xs && v.find(t) || [] |}.fn($0)))'.fn(),
                            replace: '@xs[$0] = $1, $1 && ($1.parent = $_), $_'.fn(),
                         push_value: '! @is_value() ? (@xs.push($0), $0) : ("The token " + $0 + " is one too many for the tree " + $_ + " in the context " + $_.top() + ".").fail()'.fn(),
                          with_node: '$0 && ($0.parent = $_), @push_value($0), $_'.fn(),
                            push_op: '$0.precedence[$1] - !! ($0.right[$1] || $0.syntactic[$1]) < $0.precedence[@op] ? @graft($1) : @hand_to_parent($1)'.fn(r),
                              graft: '@push_value(@is_value() ? new $0.syntax($_, $1).with_node(@xs.pop()) : new $0.syntax($_, $1))'.fn(r),
                     hand_to_parent: '@parent ? @parent.push_op($0) : ("Syntax trees should have a minimal-precedence container when parsing " + $0 + " at " + $_).fail()'.fn(),
                                top: '@parent ? @parent.top() : $_'.fn(),
                           toString:  function () {var left_in = function (x, ops) {return x.xs && x.xs[0] && (ops[x.xs[0].op] && x.xs[0].op ||
                                                                                                               x.xs[0].xs && x.xs[0].xs[1] && ops[x.xs[0].xs[1].op] && x.xs[0].xs[1].op)},
                                                      right_in = function (x, ops) {return x.xs && x.xs[1] && ops[x.xs[1].op] && x.xs[1].op},
                                                            $_ = '';
                                                   return '([{'.indexOf(this.op) > -1 ? this.op + s(this.xs[0]) + r.openers[this.op] :
                                                                      this.op ==  '?' ? s(this.xs[0]) + ' ? ' + s(this.xs[1].xs[0]) + ' : ' + s(this.xs[2]) :
                                                   this.op == '(!' || this.op == '[!' ? s(this.xs[0]) + s(this.xs[1]) :
                                                       r.implicit_assignment[this.op] ? '(' + (this.op.charAt(0) === 'u' ? this.op.substring(1) + s(this.xs[0]) : s(this.xs[0]) + this.op) + ')' :
                                             this.xs[1] && r.connected[this.xs[1].op] ? (($_ = s(this.xs[0])).charAt($_.length - 1) === '}' ? $_ + ' ' : $_ + ';') + s(this.xs[1]) :
                                                                     r.unary[this.op] ? (r.translations[this.op] || this.op) + ' ' + s(this.xs[0]) :
                                                             r.prefix_binary[this.op] ? this.op + ' ' + s(this.xs[0]) + ' ' + s(this.xs[1]) :
                                                                 r.no_spaces[this.op] ? s(this.xs[0]) + this.op + s(this.xs[1]) :
                                                                                        s(this.xs[0]) + ' ' + this.op + ' ' + s(this.xs[1])}}),

  Macro support.
  Macros are just functions from syntax to syntax. They should behave as the identity if they don't apply to something.

                  macros: [

    Identifier sandwiching.
    Certain identifiers can be sandwiched into binary operators as if they were part of the operator name. Most binary operators are candidates for sandwiching, and several identifiers are
    included by default (see the sandwiches hash above). This could be optimized by using in-place rewriting, but using sandwich operators is not terribly common.

          function (e) {return e.xs && r.sandwich_ops[e.op] ?
            e.xs[1] && e.xs[1].op && r.sandwich_ops[e.xs[1].op] && r.sandwiches[e.xs[1].xs[0]] ? new r.syntax(e.parent, e.op + e.xs[1].xs[0] + e.xs[1].op, [e.xs[0], e.xs[1].xs[1]]) :
            e.xs[0] && e.xs[0].op && r.sandwich_ops[e.xs[0].op] && r.sandwiches[e.xs[0].xs[1]] ? new r.syntax(e.parent, e.xs[0].op + e.xs[0].xs[1] + e.op, [e.xs[0].xs[0], e.xs[1]]) :
            e : e},

    Assignment expansion.
    Since the left-hand side of +=, -=, etc. must be an lvalue, we can't say something like x['+='](y) and expect anything useful. So instead of overloading the operator, we just replace it with
    the longhand x = x + y, and let the '+' operator get replaced by the method call.

          function (e) {return e.xs && r.lvalue_assign[e.op] ? new r.syntax(null, "=", [e.xs[0], new r.syntax(null, e.op.substring(0, e.op.length - 1), e.xs)]) : e},

    Function notation.
    To alleviate some of the notational overhead of JavaScript's function definitions, I'm using the operator >$> for this purpose. > takes a low precedence, but it's a good idea to
    parenthesize each side just in case. You can use this operator without parentheses or with (though for multiple parameters you need them):

      | x >$> x + 1             // valid
      | (x) >$> x + 1           // valid
      | (x, y) >$> x + 1        // valid
      | x, y >$> x + 1          // parses as x, (y >$> x + 1)

    Note that you can't say this:

      | () >$> something

    The reason is that JavaScript's grammar forbids the use of () as an expression. To get around it, you can bind a throwaway variable:

      | _ >$> something

          function (e) {return e.op == '>$>' ? new r.syntax(e.parent, 'function').with_node (e.xs[0].op == '(' ? e.xs[0] : new r.syntax (null, '(', [e.xs[0]])).
                                                                                  with_node (new r.syntax (null, '{').with_node (new r.syntax (null, 'return').with_node (e.xs[1]))) : e},

    Function preloading.
    Since Rebase doesn't provide an expression-mode variable binding syntax (this would be difficult), binding variables becomes a matter of using functions. This has the advantage that you
    end up with a proper lexical scope too.

      | x |$> f === f(x)
      | (x, y) |$> f === f (x, y)

          function (e) {return e.op == '|$>' ? new r.syntax(e.parent, '(!').with_node (e.xs[1]).with_node (e.xs[0].op == '(' ? e.xs[0] : new r.syntax(null, '(').with_node (e.xs[0])) : e},

    Comments.
    Structural comments can be useful for removing chunks of code or for getting comments through SpiderMonkey's parse-deparse cycle (SpiderMonkey, and perhaps other JS interpreters, removes
    comments between evaling and serializing a function). Either way, the syntax is just like literal(), except that the result will be replaced with the value 'undefined' instead of evaluated
    normally.

          function (e) {return e.op == '(!' && e.xs && e.xs[0] == 'comment' ? 'undefined' : e},

    String interpolation.
    One of Ruby and Perl's great features is string interpolation. We can add this to JavaScript quite easily by writing a macro that looks for string nodes and expands them to expressions
    that build strings. Unfortunately we won't be able to distinguish between single and double-quoted strings because SpiderMonkey converts them all to double-quoted ones.

          function (e) {return e.charAt && '\'"'.indexOf(e.charAt(0)) > -1 && /#\{[^}]+\}/.test(e) ?
                               '(' + e.replace (/#\{([^}]+)\}/g, function (_, code) {return e.charAt(0) + '+(' + r.translate(code.replace(/\\(.)/g, '$1')) + ')+' + e.charAt(0)}) + ')' : e},

    Operator overloading.
    Once we're done with all of the preprocessing we can actually replace the operators with method calls. I'm cheating just a bit here; normally you would encase the operation inside a [ node
    after wrapping it as a string. However, I'm being lazy and making the excuse that maybe later on you want to detect proper method calls from generated ones; so the right-hand side of the
    [! will not be what you expect; rather, it will be a single string containing the text [">$$>"] (or some other operator).

          function (e) {return e.op && r.should_convert (e.op) ?
            new r.syntax(e.parent, "(!").with_node(new r.syntax(null, "[!", [e.xs[0], '["' + e.op + '"]'])).with_node(new r.syntax(null, '(', [e.xs[1]])) : e}]});

  Operator compatibility.
  We want to make sure that the default behavior of all normal operators is preserved. While we're at it we can give them typable names and form combinatory versions as well.

  var translate = '$0[$1] || $1'.fn(r.translations);
  d.operators = {binary: {transforms: {'$0': '"$_" + $0 + "$0"', '$0 + "_fn"': '"{|t, x| t.apply($_,@_)" + $0 + "x.apply($_,@_)|}.fn($_.fn(), $0.fn())"'},
                           operators: {plus:'+', minus:'-', times:'*', over:'/', modulo:'%', lt:'<', gt:'>', le:'<=', ge:'>=', eq:'==', ne:'!=', req:'===', rne:'!==', and:'&&', or:'||', xor:'^',
                                       bitand:'&', bitor:'|', then:',', lshift: '<<', rshift: '>>', rushift: '>>>'}},
                  unary: {transforms: {'$0': '$0($1) + "$_"'.fn(translate), '$0 + "_fn"': '"{|f| " + $0($1) + "f.fn.apply($_,@_)|}.fn($_.fn())"'.fn(translate)},
                           operators: {complement:'u~', negative:'u-', positive:'u+'}}};

  d.map (d.operators, function (_, os) {
    d.map (os.transforms, function (nt, vt) {d.functions (d.map (os.operators, function (n, v) {return d.init (nt.fn()(v).maps_to (vt.fn()(v).fn()), nt.fn()(n).maps_to (vt.fn()(v).fn()))}))})});

  r.alias_in (Array.prototype, {'*':'map', '%':'grep', '+':'concat', '/':'fold', '>>$-':'flat_map'});
              Array.prototype['<<'] = '@push($0), $_'.fn();

  r.alias_in (r.syntax.prototype, {'<<':'with_node', '*':'map'});

  Divergence inline macro support.
  Divergence promotes strings into functions with a macro mechanism very similar to the one here. Because of this, we can enable code transformation inside those inline macros, including
  translating operators into method calls, etc. By default this isn't enabled (primarily so that users of this library have a very easy way to disable operator overloading etc.) but you can
  enable it like this:

  r.enable_inline_macro = (function (enabled) {return function () {enabled || (enabled = !! d.inline_macros.push ('$0.toString()'.compose (r.transform).compose (r.parse)))}}) (false)}) ();

__WaQoSM5hMIotoujTqinlSgnspTESmZqk1hQOaCrAYDQ

meta::code('divergence-vector-lib', <<'__lBgKp7Zqx5dX8VhI0h599MQ/nuyRVS8f5p/FA8rpZQY');
Divergence vector geometry module | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license

d.rebase (function () {
  var range = n >$> (n > 0 ? range(n - 1) << n - 1 : []);

  var         unify = n >$> (x >$> (x.length ? x : this.constructor.create.apply (this, range(n) * (_ >$> x)))),
          reduction = (left, right, join, op, n) >$> (left + (range(n) * (i >$> '$_[#{i}] #{op} $0[#{i}]')).join(join) + right).compose (unify (n)),
      componentwise = reduction.fn ('new @constructor (', ')', ','),
                dot = reduction.fn ('', '', '+', '*'),
        constructor = n >$> (range(n) * (i >$> '$_[#{i}] = $#{i}') + ['@length = #{n}']).join(',').fn(),
               four = n >$> '+-*/'.split('') * (op >$> op.maps_to (componentwise (op, n))) / d.init;

  d.vector = range(6) * (n >$> d.init (constructor(n).ctor (four (n),
                                                            {'&': v >$> this * ((this % v) / (v % v)), '|': v >$> this - (this & v), '%': dot (n),
                                                        towards : (v, x) >$> this * (1.0 - x) + v * x,
                                                           unit : _ >$> this / this.distance(),  distance : _ >$> Math.sqrt (this % this),
                                                           into : _ >$> this.constructor.create.apply (this, range(arguments.length) * (i >$> this % arguments[i].unit())),
                                                           from : _ >$> range(arguments.length) * (i >$> arguments[i] * this[i]) / ((x, y) >$> x + y),
                                                       toString : _ >$> '<#{Array.prototype.join.call(this, ", ")}>'}),
                                       {create: 'new d.vector[#{n}] (#{(range(n) * (i >$> "$" + i)).join(",")})'.fn()}));
  var v3 = d.vector[3];
  d.init (v3.prototype, {'^': v >$> new v3 (this[1] * v[2] - this[2] * v[1], this[2] * v[0] - this[0] * v[2], this[0] * v[1] - this[1] * v[0]),
                      about : function (v, angle) {var b1 = v.unit(), o = this | b1, b2 = o.unit(), b3 = b1 ^ b2, l = o.distance();
                                                   return (this & b1) + b2 * (Math.cos(angle) * l) + b3 * (Math.sin(angle) * l)}})}) ();

__lBgKp7Zqx5dX8VhI0h599MQ/nuyRVS8f5p/FA8rpZQY

meta::code('lib', <<'__sgZtFcQrWTsStk90VKNDNckTry5u5riYqGzMgKo9t7M');
Cheloniidae Live is designed to render onto the HTML5 <canvas> element in much the same way that the current Java version uses the AWT to render shapes. Because JavaScript supports nearly
uniform abstraction, there are far fewer layers of abstraction here than there are in the original. Most of the code originally represented by interfaces is now just encapsulated into
functions. This impacts turtle commands, predicates, transforms, render actions, and a host of other things that are really just functions.

d.rebase.enable_inline_macro();
var cheloniidae = preprocess (d.rebase (function () {
  var   qw = s >$> s.split(/\s+/), merging_constructor = attributes >$> (attributes * (a >$> '@#{a} = ($1 || {}).#{a} || ($0 || {}).#{a}')).join (',').fn(),
                                  patching_constructor =          k >$> 'new @constructor ($_, {#{k}: $0})'.fn(),
      clip = x >$> (x < 0 ? 0 : x > 1 ? 1 : x),
        v3 = d.vector[3].create;

  d.init (Number.prototype, {degrees: '$_ / 180.0 * Math.PI'.fn()});
  d.init  (Array.prototype,  {repeat: function (n) {var xs = []; for (var i = 0; i < n; ++i) xs.push.apply (xs, this); return xs}});

  return {

Vector geometry.
  A basic setup with lines and points based on arrays. Arrays are given destructive and non-destructive componentwise arithmetic operators whose names are the same as the aliased functions
  defined by Divergence. The vector geometry operators from the original Cheloniidae library are also implemented here.

       vector:  v3,
         line: '@a = $0, @b = $1, @pen = $2'.ctor ({midpoint:     _  >$> (this.a + this.b) / 2.0,
                                                       depth:     v  >$> (v - this.midpoint()).distance(),
                                       adjust_for_positive_z: (a, b) >$> (a[2] <= 0 && b[2] <= 0 ? null : a[2] <= 0 ? [a.towards (b, (1.0 - a[2]) / (b[2] - a[2])), b] :
                                                                                                          b[2] <= 0 ? [a, b.towards (a, (1.0 - b[2]) / (a[2] - b[2]))] : [a, b]),
                                          initialize_context: c >$> (c.save(), c.beginPath(), this.pen.install(c), this),
                                            finalize_context: c >$> (c.stroke(), c.restore(), this),
                                                      render: v >$> ((this, v.context, adjust_for_positive_z (v.transform (this.a), v.transform (this.b))) |$>
                                                                     ((t, c, aps) >$> (aps &&
                                                                       (c |$> t.initialize_context,
                                                                        c.globalAlpha = (cheloniidae.cylindrical_thickness(aps[0] - aps[1], v.transform (t.midpoint ())), c.globalAlpha) |$>
                                                                                        cheloniidae.light_transmission |$> clip,
                                                                        c.lineWidth  *= v.scale_factor() / (aps[0][2] + aps[1][2]),
                                                                        v.scale (v.project (aps[0])) |$> (p >$> c.moveTo (p[0], p[1])),
                                                                        v.scale (v.project (aps[1])) |$> (p >$> c.lineTo (p[0], p[1])),
                                                                        c |$> t.finalize_context),
                                                                       this)))}),

Incidence angle computation and attenuation.
  The original Cheloniidae source code covers this in more detail, but the idea is that we're using some elementary differential equations to figure out how much light gets attenuated when
  traveling through a tinted medium at an angle.

      light_transmission: (thickness, opacity) >$> literal (((1.0 - opacity) / Math.exp (-opacity)) * Math.exp (-thickness * opacity)),
        planar_thickness:          (normal, v) >$> normal.distance() * v.distance() / Math.abs (normal % v),
   cylindrical_thickness:            (axis, v) >$> (axis % v |$> (d >$> 1.0 / Math.sqrt (1.0 - d * d / ((axis % axis) * (v % v))))),

Turtles.
  A turtle manages a collection of lines. You can also create a bunch of lines and render those, but a turtle maintains state in between. Turtles are immutable, but the lines they draw are
  stateful. It's perhaps an odd model, but it means that you can grab a turtle state from some time before without losing what you've drawn since. In other words, a turtle represents a
  position, direction, etc. all at a moment; you get a new turtle after a line is drawn.

       rotational_turtle: merging_constructor(qw('position direction complement pen queue')).ctor ({
                             pen: patching_constructor ('pen'),
                       draw_line: distance >$> (this.queue.push (new cheloniidae.line (this.position, this.position + (this.direction * distance), this.pen)), this),
                            move: distance >$> this.draw_line (distance).jump (distance),
                            jump: distance >$> (d.trace (this.constructor.original.toString()), new this.constructor (this, {position:   this.position + (this.direction * distance)})),
                            turn:    angle >$> new this.constructor (this, {direction:  this.direction.about (this.complement, angle)}),
                            bank:    angle >$> new this.constructor (this, {complement: this.complement.about (this.direction, angle)}),
                           pitch:    angle >$> ((this.direction ^ this.complement) |$>
                                                (axis >$> new this.constructor (this,
                                                              {complement: this.complement.about (axis, angle), direction: this.direction.about (axis, angle)})))}),

                     pen: qw('color size opacity') |$> (ps >$> merging_constructor(ps).ctor (ps * (p >$> p.maps_to (patching_constructor (p))) / d.init, {
                                                                                             install: c >$> (c.globalAlpha = this.opacity, c.strokeStyle = this.color, c.lineWidth = this.size)})),

                  turtle: state >$> new cheloniidae.rotational_turtle ({position: v3(0, 0, 0), direction: v3(0, 1, 0), complement: v3(0, 0, -1), pen: new cheloniidae.pen()}, state || {}),

Line rendering.
  We can render lines onto a canvas by transforming them into the viewspace, depth-sorting, projecting their endpoints (since projection preserves straight edges), and rendering them to the
  screen. Because Cheloniidae is a high-capacity turtle system, we allow the user to interrupt the rendering process; in JavaScript, this means using continuations separated by timeouts.
  Delimited continuations won't quite work here because they will be contained (and a timeout or interval requires escape and re-entry). Better is to do explicit queueing.

       viewport: '$0($_, $1)'.fn(d.init).ctor ({transform: '($0 - @pov).into (@forward ^ @up, @up, @forward)'.fn(),
                                                  project:  v >$> v / v[2],
                                                    scale:  v >$> v * this.scale_factor() + (v3 (this.width / 2, this.height / 2, 0)),
                                             scale_factor: '@height'.fn(),
                                                   cancel: '@timeout && clearTimeout (@timeout), @timeout = null, $_'.fn(),
                                                   render:  sort >$> (sort && this.queue.sort_by ('$1.depth($0)'.fn (this.pov)), this.intermediate_render (0)),
                                      intermediate_render:  offset >$> (this.queue.slice (offset, offset + this.batch).each ((l >$> l.render (this)).bind (this)),
                                                                        this.timeout = offset + this.batch < this.queue.length &&
                                                                                       setTimeout (this.intermediate_render.bind (this).fn (i), this.delay || 10), this),
                                                    slide:  (x, y) >$> (this.pov += (this.forward ^ this.up) * x + this.up * y, this),
                                                     zoom:      z  >$> (this.pov += this.forward * z, this),
                                                     turn:  angle  >$> (this.pov  = this.pov.about (this.up, angle), this.forward = this.forward.about (this.up, angle), this),
                                                    pitch:  angle  >$> ((this.forward ^ this.up) |$> (right >$> (this.pov     = this.pov.about     (right, angle),
                                                                                                                 this.forward = this.forward.about (right, angle).unit(),
                                                                                                                 this.up      = this.up.about      (right, angle).unit(), this)))})}})) ();
__sgZtFcQrWTsStk90VKNDNckTry5u5riYqGzMgKo9t7M

meta::code('main', <<'__Uoi4zwPLtOi9Wk0CDY9sgowws7OI6tmAMWwgaN3ydj8');
Cheloniidae Live | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license

var preprocess = d.id;

:: get lib
__Uoi4zwPLtOi9Wk0CDY9sgowws7OI6tmAMWwgaN3ydj8

meta::code('scratch', <<'__UFvA92B98GVzh3boXGxl19QiD9162rJI14MuI2vyVq0');
This is for scratchwork that isn't part of your system. It could be used for testing or other experimentation.
:: get main
__UFvA92B98GVzh3boXGxl19QiD9162rJI14MuI2vyVq0

meta::data('default-action', <<'__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc');
shell
__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc

meta::data('meta-associations', <<'__PRn3E4sEYBafwIXKC61VRabCemMeSeRn2H7z3wLgOo4');
^function:: .pl
^internal_function:: .pl
^meta:: .pl
^bootstrap:: .pl
^code:: .ljs
^vim_highlighter:: .vim
__PRn3E4sEYBafwIXKC61VRabCemMeSeRn2H7z3wLgOo4

meta::data('name', <<'__vHKk1ncXnibUxzEeUrqxj118OOVsQoFldjfEmGgKpGg');
cheloniidae-live
__vHKk1ncXnibUxzEeUrqxj118OOVsQoFldjfEmGgKpGg

meta::function('add-to', <<'__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q');
my ($filename) = @_;
my @members = grep /^implementation::/, keys %data;

for (@members) {
  my $destination_name = basename($_);
  open my($handle), "| $filename import $destination_name" or messages::error("Attribute $_ could not be written.");
  print $handle retrieve($_);
  close $handle;
}
__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q

meta::function('attributes', <<'__SHSGXpl5WufcHc7hGxs0XPxlKSgo0XQ752HpjI4rgRg');
grep /^attribute::/, sort keys %data;
__SHSGXpl5WufcHc7hGxs0XPxlKSgo0XQ752HpjI4rgRg

meta::function('cat', <<'__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk');
my ($name) = @_;
$data{$name};
__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk

meta::function('clone', <<'__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY

meta::function('code', <<'__NBNecoJ9JVwyGbA+8LrNYjQKQyQOxdFAkjgZ4ueT5QA');
join "\n\n", map preprocess(retrieve("code::$_")), @_;
__NBNecoJ9JVwyGbA+8LrNYjQKQyQOxdFAkjgZ4ueT5QA

meta::function('compile', <<'__KYFqu4keMNdzCT3+cLPaeMhzerBan3li+Ky78R032Bc');
file::write('cheloniidae-live.js', unlit('main'));
file::write('cheloniidae-live.debug.js', unlit('debug'));
__KYFqu4keMNdzCT3+cLPaeMhzerBan3li+Ky78R032Bc

meta::function('cp', <<'__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4

meta::function('create', <<'__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc');
my ($name, $value) = @_;
messages::error("Attribute $name already exists.") if grep {$_ eq $name} keys %data;
if ($value) {
  associate($name, $value);
} else {
  associate($name,'');
  edit ($name);
}
__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc

meta::function('edit', <<'__rAkSOSll0evjt/D0qmnz2M++ACqz6cPtN8TLTHdQUJE');
my ($name, %options) = @_;

my $meta_extension = join '', grep {
  my $s = $_;
  $s =~ s/\s.*$//;
  $name =~ /$s/
} split /\n/, &{'meta-associations'}();

$meta_extension =~ s/^.*\s//;
chomp $meta_extension;

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $meta_extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
delete $data{$name} if length($data{$name}) == 0;

save();
__rAkSOSll0evjt/D0qmnz2M++ACqz6cPtN8TLTHdQUJE

meta::function('exists', <<'__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk');
my $name = shift;
grep {$_ eq $name} keys %data;
__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk

meta::function('export', <<'__I4eRG7HtLDZhFgrlr0QDrQO5MRwJYGFlotQsWQIE/d8');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map {cat($_)} @attributes;
  file::write ($name, $file);
} else {
  messages::error ("Not enough arguments");
}
__I4eRG7HtLDZhFgrlr0QDrQO5MRwJYGFlotQsWQIE/d8

meta::function('grab', <<'__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8');
my ($filename, @attribute_names) = @_;
associate("implementation::$_", `$filename cat $_`) for @attribute_names;
__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8

meta::function('import', <<'__7f1Q36AcIJ8/OaaYPGUq10PPFTKnEF0CMxS56DRsjKk');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__7f1Q36AcIJ8/OaaYPGUq10PPFTKnEF0CMxS56DRsjKk

meta::function('listing', <<'__ISxcI25BrOnRRxDUQm5UL5wWzHJxL/OY8QdSUdnRJoE');
my ($profile, $line, $context) = @_;
$line    ||= 1;
$context ||= 4;

my $result = '';
my @lines  = split /\n/, unlit($profile);
for my $l ($line - $context .. $line + $context) {
  next if $l <= 0;
  last if $l >  @lines;
  $result .= sprintf "\033[1;34m%6d\033[0;0m: %s%s%s\n", $l, $l == $line ? "\033[1;32m" : '', $lines[$l - 1], $l == $line ? "\033[0;0m" : '';
}

$result;
__ISxcI25BrOnRRxDUQm5UL5wWzHJxL/OY8QdSUdnRJoE

meta::function('load-dependencies', <<'__oYAWdUSIg7K9xPssNpQhu7nUGr94qBGg5QJpTDAA3sA');
my $errors = '';
for (grep length, split /\n/, &{'dependencies'}()) {
  terminal::message('loader', "Running integration test checks on $_...");
  my $output = `$_ :check`;
  chomp $output;
  $errors .= $output ? "module $_\n$output\n" : '';
}

return terminal::message('error', "dependency loading failed:\n$errors") if $errors;
associate('code::cached-dependencies', join('', map `$_ :export`, grep length, split /\n/, &{'dependencies'}()));
terminal::message('loader', "imported dependencies");
__oYAWdUSIg7K9xPssNpQhu7nUGr94qBGg5QJpTDAA3sA

meta::function('lock', <<'__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y

meta::function('ls', <<'__OlQOgKhp6VUThx34wxmM3MFkwsHfR/c8dqvu07z059E');
my $criteria = join '|', @_;
my @lines = grep /$criteria/, sort keys %externalized_functions;
my $length = 0;
$length >= length($_) or $length = length($_) for @lines;

my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . $externalized_functions{$_}, @lines);
join("\n", sort @new_lines);
__OlQOgKhp6VUThx34wxmM3MFkwsHfR/c8dqvu07z059E

meta::function('ls-a', <<'__S5EydJRu+YIfcFmTMz1ZHX0cANJq32bU5JnYCe1tWdk');
my $criteria = join '|', @_;
my @lines    = grep(/$criteria/, sort keys %data);
my $length   = 0;

my %inverses;
$inverses{$externalized_functions{$_}} = $_ for keys %externalized_functions;

$length >= length($_) or $length = length($_) for @lines;
my @new_lines = map($_ . ' ' x ($length + 2 - length($_)) . ($inverses{$_} || ''), @lines);
join "\n", @new_lines;
__S5EydJRu+YIfcFmTMz1ZHX0cANJq32bU5JnYCe1tWdk

meta::function('mv', <<'__ijyNZ8r34FVK0Ki9/Q0Irx5k9U0pZ+/frrdlu+qkEP4');
my ($from, $to) = @_;
messages::error("The '$from' attribute does not exist.") unless grep $from, keys %data;
associate($to, retrieve($from));
rm($from);
__ijyNZ8r34FVK0Ki9/Q0Irx5k9U0pZ+/frrdlu+qkEP4

meta::function('perl', <<'__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA');
my $result = eval($_[0]);
$@ ? $@ : $result;
__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA

meta::function('pop-state', <<'__eqnCLsMapvq2sYSx82KCxh25zmff+JIXFMYUan2kGKM');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__eqnCLsMapvq2sYSx82KCxh25zmff+JIXFMYUan2kGKM

meta::function('preprocess', <<'__SP+M4pf8VRk5hJv0AVOHi8DdG8vAj6ClENKjab8Vbg8');
my ($document) = @_;
my %commands = (get => sub {"\n" . code(split /\s+/, $_[0]) . "\n"});
join "\n", map {m/^\s*::\s*(\w+)\s(.*)$/o && defined $commands{$1} ? $commands{$1}($2, $_) : $_} split /\n/, $document;
__SP+M4pf8VRk5hJv0AVOHi8DdG8vAj6ClENKjab8Vbg8

meta::function('pull', <<'__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg

meta::function('push-state', <<'__ik0ofu7R8gHAKSmMjek79V+yfgdjdK5Jmtwf7h8SpJk');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__ik0ofu7R8gHAKSmMjek79V+yfgdjdK5Jmtwf7h8SpJk

meta::function('reload', <<'__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM');
execute($_) for (grep {! (/^internal::/ || /^bootstrap::/)} keys %data);
__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM

meta::function('repl', <<'__w4q9MpioWHnb4gpiwN2R0N69hoQm0kvxzUBS6knEULg');
my ($name, @options) = @_;

use Term::ReadLine;

my $term = new Term::ReadLine "$0 repl for $name";
$term->ornaments(0);
my $OUT    = $term->OUT || \*STDOUT;
my $prompt = &{'name'}() . "/$name> ";

terminal::message('repl', 'initializing symbol table');
types::clear_symbols();
types::load_symbols($name) if $name;
types::initialize_symbols();
types::initialize_debugging_symbols() if grep /^debug$/, @options;

terminal::message('repl', 'running session');
run('cached-dependencies') unless grep /^nodeps$/, @options;
run($name) if $name;

terminal::message('repl', 'ready');
while (defined ($_ = $term->readline($prompt))) {
  my $result = eval {reader::read_form($_)->eval()->serialize()};
  $@ ? chomp $@ && terminal::message('error', $@) : terminal::message('result', $result);
}

print "\n";
if ($name) {
  terminal::message('repl', 'storing symbol table');
  types::store_symbols($name);
}

terminal::message('repl', 'exiting');
__w4q9MpioWHnb4gpiwN2R0N69hoQm0kvxzUBS6knEULg

meta::function('rm', <<'__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww

meta::function('run', <<'__2RluS4s8uRjHD6Vtfi/a01P+Bo8jgpcLILqPCD4icpU');
shell::load_interactively(@_);
__2RluS4s8uRjHD6Vtfi/a01P+Bo8jgpcLILqPCD4icpU

meta::function('run-file', <<'__WceprRaNezbwObGfB9h6pwi0Ly281gdWz8CLtXL1ehY');
shell::initialize_symbol_table();
&{':main'}();
shell::load_from_file(@_);
__WceprRaNezbwObGfB9h6pwi0Ly281gdWz8CLtXL1ehY

meta::function('save', <<'__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw');
my $serialized_data = serialize();
my $final_state     = state();

my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

my $observed_state = `perl $temporary_filename state`;
chomp $observed_state;
if ($observed_state ne $final_state) {
  messages::error("The state of this object ($final_state) is inconsistent with the state of $temporary_filename ($observed_state).\n" .
                  "$0 has not been updated.");
} else {
  eval {file::write($0, $serialized_data)};
  warn $@ if $@;
  my $observed_self_state = `perl $0 state`;
  chomp $observed_self_state;
  unlink $temporary_filename if $observed_self_state eq $final_state;
}
__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw

meta::function('serialize', <<'__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw');
my @keys_without_internals = grep(!/^internal::/, sort keys %data);
join "\n", $data{'bootstrap::initialization'},
           (grep {$_} (map {serialize::single(@_)} grep(/^meta::/,  @keys_without_internals),
                                                   grep(!/^meta::/, @keys_without_internals),
                                                   grep(/^internal::/, sort keys %data))),
           "__END__";
__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw

meta::function('shell', <<'__mzNaDzdnJhpI/Va1/nY8LTN9BQtfr77CFKIeK2GdIC0');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = &{'name'}() . '$ ';
my $OUT = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      my $result = eval {&{$function_name}(@args)};
      messages::warning($@) if $@;
      chomp $result;
      print $OUT $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  for my $watch (@{$transient{'watch_list'}}) {
    print $OUT eval($watch), "\n";
    print $OUT "Error evaluating watched expression $watch: $@\n" if $@;
  }

  $prompt = &{'name'}() . '$ ';
}
__mzNaDzdnJhpI/Va1/nY8LTN9BQtfr77CFKIeK2GdIC0

meta::function('size', <<'__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80');
length(serialize());
__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80

meta::function('snapshot', <<'__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0

meta::function('state', <<'__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI');
sha256_base64 serialize();
__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI

meta::function('unlit', <<'__4zPHXwlGFrTN0OAvy0k5UFlrLmXg6SUA8aJM9GyFDko');
join "\n\n", map {m/^\s*[^0-9a-z_()\[\]{}!\/ ]/o ? s/^/\/\/ /omg : s/^(\s*)!/\1 /o; $_} split /\n\n+/, code(@_);
__4zPHXwlGFrTN0OAvy0k5UFlrLmXg6SUA8aJM9GyFDko

meta::function('unlock', <<'__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA

meta::function('update-from', <<'__jJ2tfSk/Quz8/1PiYxIwQjBRt/hYg51iJhAdxcdaHkM');
# Upgrade all attributes that aren't customized. In this case, we want everything except for configuration::, code::, and attribute::.
return "That is a really bad idea." if $0 =~ /\.\/(.*)/ && $_[0] eq $1 || $_[0] eq $0;

my @attributes = map {s/\s+.*//; $_} split(/\n/, qx|$_[0] ls-a|);

terminal::message('info', 'Replicating state...');
&{'push-state'}();
terminal::message('info', 'Updating meta attributes...');
for my $attribute (grep length && /^meta::/, @attributes) {
  associate($attribute, join('', qx|$_[0] cat $attribute|));
  reload();
  print '.';
}

print "\n";
terminal::message('info', 'Updating non-meta attributes...');
for my $attribute (grep length && ! (/^configuration::/ || /^code::/ || /^attribute::/ || /^function::pop-state$/ ||
                                     /^list::/ || /^issue::/ || /^data::/ || /^meta::datatypes/), @attributes) {
  associate($attribute, join('', qx|$_[0] cat $attribute|));
  reload();     # Necessary to activate new datatypes.
  print '.';
}

print "\n";
terminal::message('info', 'Reloading new configuration');
reload();
terminal::message('info', "Imported from $_[0]. Run pop-state to undo this change.");
__jJ2tfSk/Quz8/1PiYxIwQjBRt/hYg51iJhAdxcdaHkM

meta::function('usage', <<'__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I');
<<"EOD" . join '  ', split /\n/, ls ();
Usage: $0 [options] action [arguments]
Defined actions:
EOD
__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I

meta::function('vim', <<'__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for map {s/^vim_highlighter:://o; $_} grep /^vim_highlighter::/, sort keys %data;
__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec

meta::internal_function('associate', <<'__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless grep {$_ eq $namespace} @data_types;
$data{$name} = $value;
execute($name) if $options{'execute'};
__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0

meta::internal_function('basename', <<'__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw

meta::internal_function('complete', <<'__lhlD80z2kvEUEeHPqLFw6JE8xUdXr6J5Q1gXHg4beHg');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__lhlD80z2kvEUEeHPqLFw6JE8xUdXr6J5Q1gXHg4beHg

meta::internal_function('execute', <<'__Ge94WTpmLuqsMDappj5G/G2BKILAE0GjeCqAeHLW6fQ');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__Ge94WTpmLuqsMDappj5G/G2BKILAE0GjeCqAeHLW6fQ

meta::internal_function('file::read', <<'__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg

meta::internal_function('file::write', <<'__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o

meta::internal_function('invoke_editor_on', <<'__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U');
my ($data, %options) = @_;
my $content_hash     = sha256_base64($data);
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my (undef, $filename) = tempfile("$0." . ("X" x 32), OPEN => 0);
$filename .= $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U

meta::internal_function('messages::error', <<'__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4');
my ($message) = @_;
die "$message\n";
__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4

meta::internal_function('messages::warning', <<'__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc');
my ($message) = @_;
print "$message\n";
__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc

meta::internal_function('namespace', <<'__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug

meta::internal_function('retrieve', <<'__Erqqkp11FEHKsitr0DEJZ6OCGDYAs+U6BSu4UvLvsFM');
@data{@_};
__Erqqkp11FEHKsitr0DEJZ6OCGDYAs+U6BSu4UvLvsFM

meta::internal_function('serialize::single', <<'__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = "__" . sha256_base64 $contents;
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE

meta::internal_function('state_based_filename', <<'__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw

meta::library('terminal', <<'__bakqo5o+Exi5Kw4onujvi9Pu3zR9lQA8cPKfYj6L74Q');
# Functions for nice-looking terminal output.

package terminal;

use constant black  => "0;0";
use constant red    => "1;31";
use constant yellow => "1;33";
use constant green  => "1;32";
use constant blue   => "1;34";
use constant purple => "1;35";
use constant cyan   => "1;36";

my %default_colors = (info => green);
my $longest_prefix = 0;
$longest_prefix = $longest_prefix < $_ ? $_ : $longest_prefix for map length, keys %default_colors;

sub message {
  my ($prefix, $message) = @_;
  my $color = $default_colors{$prefix};
  my $padding = ' ' x ($longest_prefix - length $prefix);
  print "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__bakqo5o+Exi5Kw4onujvi9Pu3zR9lQA8cPKfYj6L74Q

meta::sh('js', <<'__qGEHHjKcAKXQz3fhJNhOtnWH3pjzV5E13Ndz4KxZrvs');
js __code__
__qGEHHjKcAKXQz3fhJNhOtnWH3pjzV5E13Ndz4KxZrvs

meta::sh('node', <<'__SSgRGyOQPbEleu+2TMjU4OCmMnjOWFSaJj0iwGkBsug');
node __code__
__SSgRGyOQPbEleu+2TMjU4OCmMnjOWFSaJj0iwGkBsug

meta::sh('node-repl', <<'__q9vTbSQ20/rHKteKvyoqfWOUHbXPrRXR8WvCi2vaMDY');
node-repl __code__
__q9vTbSQ20/rHKteKvyoqfWOUHbXPrRXR8WvCi2vaMDY

meta::sh('repl', <<'__hpfIOvOFVwSLotcBcirerUZLwIeNISkgfqy8K01Nbk8');
js -f __code__ -f -
__hpfIOvOFVwSLotcBcirerUZLwIeNISkgfqy8K01Nbk8

meta::sh('stats', <<'__e/Rj98I2/T+yRRdecrhlw5H3dWmBW2Vup15b2cbzKLg');
echo $(cat __code__ | grep -v '//' | grep -v '^\s*$' | wc -l) LOC, \
     $(cat __code__ | grep '//' | wc -l) comment lines, \
     $(cat __code__ | grep '^\s*$' | wc -l) whitespace lines
__e/Rj98I2/T+yRRdecrhlw5H3dWmBW2Vup15b2cbzKLg

meta::vim_highlighter('ljs', <<'__EELq7R8BHu1htK8/oKRUrIUWVVYqdfaJgsvdyUimtss');
" Literate JavaScript | Spencer Tipping <spencer@spencertipping.com>

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn include @javascript syntax/javascript.vim

syn match ljsGetDirective /::\s*get\s.*$/     contained
syn cluster directives add=ljsGetDirective

syn case match
syn region lCodeRegion    start=/^\s*[\/!0-9a-z_()\[\]{}'"]/   end=/^$/ contains=@javascript transparent fold
syn region lCommentRegion start=/^\s*[^\/!0-9a-z_()\[\]{}'" ]/ end=/^$/ contains=@directives fold

hi link lCommentRegion  comment
hi link ljsGetDirective special

set foldmethod=syntax

let b:current_syntax = "ljs"
__EELq7R8BHu1htK8/oKRUrIUWVVYqdfaJgsvdyUimtss

meta::internal('runtime', <<'__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ');
my $initial_state = sha256_base64 serialize();

push @script_args, shift @ARGV while @ARGV && $ARGV[0] =~ /^-/;

my $default_action = retrieve('data::default-action');
chomp $default_action;
my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};
my $result = &{$function_name}(@ARGV);
chomp $result;
print "$result\n" if $result;

END {
  my $serialized_data = serialize();
  my $final_state     = sha256_base64 $serialized_data;
  save() unless $initial_state eq $final_state;
}

__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ

__END__